.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Mitomaster::Manual 3"
.TH Bio::Mitomaster::Manual 3 "2012-03-05" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.IP "Bio::Mitomaster Manual" 8
.IX Item "Bio::Mitomaster Manual"
.SH "CONTENTS"
.IX Header "CONTENTS"
Read the \s-1OVERVIEW\s0 and \s-1BASICS\s0 first.
.IP "\s-1OVERVIEW\s0" 4
.IX Item "OVERVIEW"
.PD 0
.IP "\s-1BASICS\s0" 4
.IX Item "BASICS"
.IP "\s-1SEQS\s0 \- analyzing mitochondrial sequences" 4
.IX Item "SEQS - analyzing mitochondrial sequences"
.IP "\s-1FILETYPES\s0 \- supported file formats" 4
.IX Item "FILETYPES - supported file formats"
.IP "\s-1TREES\s0 \- building phylogenetic trees from mtDNA (not implemented yet)" 4
.IX Item "TREES - building phylogenetic trees from mtDNA (not implemented yet)"
.IP "\s-1COMPRESSION\s0 \- creating efficient encodings for mtDNA sequences" 4
.IX Item "COMPRESSION - creating efficient encodings for mtDNA sequences"
.IP "\s-1SPECIES\s0 \- list of currently supported species and how to add new ones" 4
.IX Item "SPECIES - list of currently supported species and how to add new ones"
.IP "\s-1DOCUMENTATION\s0 \- where to get more information" 4
.IX Item "DOCUMENTATION - where to get more information"
.PD
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Bio::Mitomaster is a software framework that makes it easy to create programs that analyze mitochondrial genomic data of species for which there is an established reference sequence.  This short manual provides an overview for its use and lists other sources of documentation.  
This software is developed by Marty Brandon at the Center for Molecular and Mitochondrial Medicine and Genetics, located at \s-1UC\s0, Irvine, and is free to use and modify as desired.  It's in regular use powering the online \s-1MITOMASTER\s0 analysis tools: <http://mitomaster.bio.uci.edu>.
.SH "BASICS"
.IX Header "BASICS"
.SS "Bio::Mitomaster"
.IX Subsection "Bio::Mitomaster"
Always begin your analysis by creating a Bio::Mitomaster object.  Use this object to produce Seq objects, which can produce RNASeq objects, which can in turn produce AASeq objects.  Each type of object tries to somewhat mimic what you might expect in nature:
.PP
.Vb 3
\& use Bio::Mitomaster;
\& $mm = Bio::Mitomaster\->new;  # Always begin with this
\& print $mm\->species;    # prints \*(Aqhuman\*(Aq, the default species
.Ve
.PP
Mitomaster objects are specific for a species-reference combination.  When not explicity specified, these default to 'human' and 'rCRS' (revised Cambridge sequence), respectively.
.PP
.Vb 1
\& $mm = Bio::Mitomaster\->new(species=>\*(Aqhuman\*(Aq, reference=>\*(AqrCRS\*(Aq);  # same as above \- \*(Aqhuman\*(Aq and \*(AqrCRS\*(Aq are the defaults
.Ve
.PP
Your Mitomaster object serves mostly as a gateway to your analyses, but it can provide useful reference information:
.PP
.Vb 2
\& print $mm\->ref_seq(101,110);  # prints a string of ten nucleotides from the reference sequence starting at position 101.
\& $c = $mm\->codon_code(\*(AqTTT\*(Aq);  # $c is now \*(AqF\*(Aq
.Ve
.SS "Mitomaster Object Methods:"
.IX Subsection "Mitomaster Object Methods:"
All methods listed here are context-specific for the particular species analyzed.  The software does not \*(L"know\*(R" any details for a given species, but instead reads it in from species-specific data files.  This allows for easy extension, but makes adding the supporting data files for a species a prerequisite (see \s-1SPECIES\s0 section).
.PP
\fIcodon_code\fR
.IX Subsection "codon_code"
.PP
Translates a three-letter codon into its single-letter \s-1IUPAC\s0 amino acid code.
.PP
.Vb 1
\& $c = $mm\->codon_code(\*(AqTTT\*(Aq);  # $c is now \*(AqF\*(Aq
.Ve
.PP
\fIspecies_list\fR
.IX Subsection "species_list"
.PP
Returns a list of supported species, ref sequence combinations which are currently supported.  You might be interested in calling this as a class method, maybe from the command line?  That way you can quickly check to see which combinations are currently supported.
.PP
.Vb 2
\& print "Bio::Mitomaster currently supporst the following species\-refseq combinations:\en";
\& print Bio::Mitomaster::species_list();
.Ve
.PP
or from the command line:
.PP
.Vb 1
\& perl \-mBio::Mitomaster \-e \*(Aqprint Bio::Mitomaster::species_list\*(Aq;
.Ve
.PP
It should return something like:
.PP
.Vb 2
\& \*(Aqhuman, rCRS\*(Aq
\& . . .
.Ve
.PP
Those are the supported species and ref sequence combinations currently supported and can be used to instantiate your Bio::Mitomaster object.
.PP
\fIlocus\fR
.IX Subsection "locus"
.PP
Returns information about the known locus regions within the reference genome.
.PP
.Vb 2
\& my $hash_table_ref = $mm\->locus;  # reference to a hash with locus numbers as indices each pointing to its own hash
\& my $locus_ref = $mm\->locus(3);  # reference to a hash of info for locus number three
.Ve
.PP
\fIprotein\fR
.IX Subsection "protein"
.PP
Behaves the same as the locus method, but for the poly-peptides that are encoded (and characterized) by the genome.
.PP
.Vb 2
\& my $protein_table_ref = $mm\->protein;  # reference to a hash with locus numbers as indices each pointing to its own hash
\& my $protein_ref = $mm\->locus(6);  # reference to a hash of info for the protein encoded by locus number six
.Ve
.PP
\fIref_seq\fR
.IX Subsection "ref_seq"
.PP
Used to access the reference sequence.  This will be a nucleotide string when called on a Mitomaster object, but this method will produce an \s-1RNA\s0 or \s-1AA\s0 string when called on a different type of object (see below).
.PP
.Vb 3
\& $mm\->ref_seq          # string representing the full reference sequence
\& $mm\->ref_seq($n)      # single moiety at position $n
\& $mm\->ref_seq($s,$e)   # string of moieties in the range $s to $e
.Ve
.PP
If the first index is larger than the second and the wrapping attribute is set (see below) then the last nucleotide is assumed to be a neighbor to the first.  For human seqs using the rCRS as a reference
.PP
.Vb 1
\& $mm\->ref_seq(16567,2)
.Ve
.PP
produces the last three nucleotides with the first two concatenated to the end.
.PP
\fIseq\fR
.IX Subsection "seq"
.PP
Returns a Seq object representing a \s-1DNA\s0 sequence from either a sequence file or list of nucleotide variants.  This is the preferred way to produce Bio::Mitomaster::Seq objects, which are used to represent \s-1DNA\s0 sequences.  Think of the Mitomaster object as like a little factory for producing new Seq objects via the seq method.
.PP
File names must have a recognizable extension to identify the type (see \s-1FILETYPES\s0 for supported types).  If you are using partial sequences, then a start and end values should be specified to prevent the gap as being detected as a large deletion.  See \s-1SEQS\s0 below for more about using Seq objects.
.PP
.Vb 3
\& $seq_obj = $mm\->seq(file=>\*(Aqmy_file.fas\*(Aq);
\& $seq_obj = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3=>\*(AqC\*(Aq});
\& $seq_obj = $mm\->seq(file=>\*(Aqmy_file.fas\*(Aq, start=>577, end=>16023);
.Ve
.PP
\fItranscript\fR
.IX Subsection "transcript"
.PP
Returns either a string representing an \s-1RNA\s0 sequence from the reference sequence or a hash reference to a table of information depending on how it is called.  Calling it without any argument returns a reference to a table of all transcripts known for this species (indexed by locus ID#).  Specify a locus ID# as an argument and you get a string for that locus.  Adding position indices will return a substring.
.PP
.Vb 3
\& $t = $mm\->transcript(16);  # $t contains the transcript string for the Cytochrome oxidase subunit I
\& $t = $mm\->transcript(16,1,10);  # same thing but only the first 10 nucleotides
\& $t = $mm\->transcript();  # $t is a reference to a hash that contains all the mitochondrially encoded transcripts indexed by locus ID#
.Ve
.PP
\fItranslation\fR
.IX Subsection "translation"
.PP
Used to access the reference translation sequences.  Works just like the transcript method above, but for the reference poly-peptide sequences.
.PP
\fIwrapping\fR
.IX Subsection "wrapping"
.PP
This is a boolean value read from the meta-data for the species, which causes sequences to wrap when set.  There are actually three attributes (dna_wrapping, rna_wrapping, and aa_wrapping), but this is an alias for dna_wrapping (the one you probably want).  Generally, if your species has a circular genome, then you want this set, but it will probably be set automatically, so you don't really need to worry about it unless you are get sub sequences that cross the ending/beginning boundary and things are working as you would expect.  You can also force wrapping behavior for \s-1RNA\s0 and \s-1AA\s0 seqs by setting rna_wrap and aa_wrap, respectively.
.SH "SEQS"
.IX Header "SEQS"
Typically, you would begin an analysis by creating a Mitomaster object and then calling the seq method on that object to produce Seq objects (see seq method above).  A Seq object models a real \s-1DNA\s0 sequence.  It has a transcribe method that produces an RNASeq object, which itself has a translate method that produces an AASeq object.  \s-1SEQS\s0 (all caps) is used here to refer to Seq, RNASeq, and AASeq objects collectively since they share commonalities in their interface.  A nice thing about these \s-1SEQ\s0 objects is that they carry around access to their species reference information.  They also modify the behavior of their interface to match the context, so calling ref_seq on a Seq object produces a \s-1DNA\s0 nucleotide string, but when called on a RNASeq object it produces an \s-1RNA\s0 string.
.SS "\s-1DNA\s0 Seqs"
.IX Subsection "DNA Seqs"
To produce a new Seq object, a Mitomaster object needs either a list of variants or a sequence file (see \s-1FILETYPES\s0 for supported formats).
.PP
.Vb 1
\& $dna_seq = $mm\->seq(file=>\*(Aq/tmp/my_file.fas\*(Aq);
.Ve
.PP
Assuming that 'my_file.fas' had been a properly formatted mtDNA fasta file, the above statement creates a new Bio::Mitomaster::Seq object using the seq method of the previously created Mitomaster object.  In creating the Seq object, the sequence read from the file will be automatically aligned with its reference and all variant nucleotides identified.
.PP
.Vb 5
\& # Produce an ordered list of the variants found
\& $variants = $dna_seq\->variants;
\& for (sort {$a <=> $b} keys %{$variants}) {
\&     print $_, \*(Aq \*(Aq, $variants\->{$_};
\& }
.Ve
.PP
Seq objects can also be created from a list of variants.
.PP
.Vb 2
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3=>\*(AqC\*(Aq});
\& print $dna_seq\->seq;  # AAC . . .
.Ve
.PP
The print statement above will display the full \s-1DNA\s0 sequence reconstructed from its ref sequence and the variants at positions 1 and 3.  The list of variants can also be put into a file with a .variants extension (see the variant File Type section).  Don't confuse the seq method of a Mitomaster object with the seq method of a Seq object.  Mitomaster objects are like little factories for producing Seq objects, while Seq objects use their seq method to reveal their string of nucleotides (RNASeq and AASeq objects behave similarly to Seq objects \*(-- see below).
.PP
Deletions variants are represented with a '\-'.
.PP
.Vb 4
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3=>\*(Aq\-\*(Aq});
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3=>\*(Aq\-\-\*(Aq});  # a 2bp deletion at position 3
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3=>\*(Aq\-\*(Aq, 4=>\*(Aq\-\*(Aq});  # the same sequence, but with two separate deletion events
\& print $dna_seq\->seq;  # AA\-\- . . .
.Ve
.PP
Note that dashes are left in the string returned as placeholders for the deletions.  To remove them, use some basic Perl ($seq_string =~ s/\-//g;).
.PP
Specify insertions using decimal numbers.
.PP
.Vb 1
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3.01=>\*(AqG\*(Aq});  # a guanine insertion between positions 3 and 4
.Ve
.PP
Any decimal values will work so long as the numbers give the correct ordering of the variants.
.PP
.Vb 2
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3.01=>\*(AqGA\*(Aq});  # GA insertion between positions 3 and 4
\& $dna_seq = $mm\->seq(variants=>{1=>\*(AqA\*(Aq, 3.001=>\*(AqG\*(Aq, 3.002=>\*(AqA\*(Aq});  # Same thing
.Ve
.PP
Use start and end values to indicate partial sequences.
.PP
.Vb 1
\& $dna_seq = $mm\->seq(file=>\*(Aqmy_file.fas\*(Aq, start=>577, end=>16023);  # reading a fasta file with only partial coverage
.Ve
.PP
Now calling the seq method will produce a nucleotide string with everything before 'start' and after 'end' trimmed.  More importantly, the alignment algorithm will use the start and end values you provide, so that it doesn't create a large deletion variant for the region absent.  When not explicitly set, start and end default to the values for the reference sequence (1 and 16569 for the human rCRS sequence).
.PP
Put any other data you might want to associate with the sequence into the info hash.
.PP
.Vb 1
\& $dna_seq = $mm\->seq(file=>\*(Aqmy_file.fas\*(Aq, info=>{name=>\*(Aqseq1\*(Aq, donor=>\*(AqInuit\*(Aq});  # associates a name and donor value
.Ve
.PP
Anything may be put into the info hash.  You choose the keys and values to use.  Anthing in the hash is available through a method called 'info':
.PP
.Vb 1
\& print $dna_seq\->info(\*(Aqname\*(Aq);  # prints \*(Aqseq1\*(Aq
.Ve
.PP
Seq objects have a seq method.  Like the ref_seq method on Mitomaster objects, you can use it to return any part of a sequence by specifying position indices.
.PP
.Vb 1
\& print $dna_seq\->seq(101,110);  # displays a string representing 10 nucleotide positions
.Ve
.SS "\s-1RNA\s0 Seqs"
.IX Subsection "RNA Seqs"
Having created a Seq object representing some \s-1DNA\s0, you might now be interested in the \s-1RNA\s0 that would be transcribed, so use the transcribe method of a Seq to produce an RNASeq object representing the transcript that would be transcribed.
.PP
.Vb 1
\& $rna_seq = $dna_seq\->transcribe(locus=>\*(Aq13\*(Aq);
.Ve
.PP
RNASeq objects are specific to a particular locus region, so a locus \s-1ID\s0 value must be supplied to transcribe.  The locus method (see below) returns a table with all the defined loci regions.  You can also define an info hash for the transcript (see \s-1DNA\s0 Seq).
.SS "\s-1AA\s0 Seqs"
.IX Subsection "AA Seqs"
As you might have expected, an RNASeq object has a translate method to produce an AASeq object that represents the poly-peptide sequence it would produce.
.PP
.Vb 1
\& $aa_seq = $rna_seq\->translate;
.Ve
.PP
Because RNASeq objects are for a specific locus region, it isn't necessary to specify the locus \s-1ID\s0 that you want translated (to translate a different locus, you need another RNASeq object).  You can also define an info hash for the translation (see \s-1DNA\s0 Seq).
.PP
So, the three varities of macromolecules are represented in this software as Seq, RNASeq, and AASeq objects for \s-1DNA\s0, \s-1RNA\s0, and \s-1AA\s0, respectively.  Mitomaster objects are a sort of factory that you create first to establish the species and ref sequence context.  Mitomaster objects produce Seq objects with the seq method, Seq objects produce RNASeq objects with the transcribe method, and RNASeq objects produce AASeq objects with the translate method.  Each of these objects has a similar interface, but it functions contextually: calling seq on a Seq object will produce a string of nucleotides, while the same call on an AASeq object will produce a string of amino acids.  And all objects in the framework operate contextually according to the combination of species and ref sequence determined when you create the Mitomaster object.
.SS "\s-1SEQ\s0 Methods"
.IX Subsection "SEQ Methods"
In addition to the methods below, Seq objects have all the methods for interrogating the reference sequence that Mitomaster objects have with the exception that the ref_seq method is context specific: calling ref_seq on a Seq object (\s-1DNA\s0) will return a string representing \s-1DNA\s0, while the same method call on an RNASeq object will produce a string representing \s-1RNA\s0.  Reference sequence strings returned are also trimmed according to the start and end values specified when creating sequence objects (see below).
.PP
.Vb 4
\& $mm = Bio::Mitomaster\->new;
\& $mm\->ref_seq;  #returns the full reference sequence
\& $dna_seq = $mm\->seq(start=>577, file=>\*(Aq/tmp/my_file.fas\*(Aq);
\& $dna_seq\->ref_seq;  #returns a ref seq minus the first 576 nucleotides
.Ve
.PP
\fIvariants\fR
.IX Subsection "variants"
.PP
The variants method seen for \s-1DNA\s0 Seq objects works equally well for \s-1RNA\s0 and \s-1AA\s0 Seq objects, though again the context is shifted to match the molecule, and position values refer to the transcript and translation position, respectively.  However, due to complications with frameshift, the variants stored in \s-1AA\s0 Seq objects are a little different.  Internally, \s-1AA\s0 Seq variants are stored as codons and only translated to amino acids, using the codon code for the particular species, as they are retrieved by the variants method.  However, you can instead switch to the underlying codon view by setting the show_codons flag on a AASeq object:
.PP
.Vb 1
\& $aa_seq\->show_codons(1);
.Ve
.PP
A reference to a hash of variants indexed by translation position will be retrieved as before, but instead of single-letter amino acid values, the codons are given.  Silent coding changes not listed in the normal list of variants will now be listed in the list of codon changes.  Variants causing a frameshift (indels) will have that information concatenated to the end of the codon value separated by a space.
.PP
So this:
.PP
.Vb 4
\& $variants = $aa_seq\->variants;
\& for (sort keys {$a <=> $b} %{variants}) {
\&    print $_, "\et", $variants\->{$_}, "\en";
\& }
.Ve
.PP
might produce something like this:
.PP
.Vb 4
\&    2   ACA
\&    10  CGC +1
\&    12  CCG +1
\&    13  GAA
.Ve
.PP
The interpretation: A codon change at the second amino acid, followed by a deletion in the 10th amino acid codon causing the frame to increment by one (insertions cause frame to decrement).  Though still frameshifted, there was no affect at the 11th amino acid position, meaning that the codon exactly matched the reference codon at position 11.  Position 12, still frameshifted from the upstream change, has another codon change.  Finally, there is a compensatory insertion at position 13 that causes the frame to return to normal, but with a codon change (a compensatory insertion that restored the codon to normal would not be listed).
.PP
\fIend\fR
.IX Subsection "end"
.PP
Retrieves the sequence end value.  This value is readonly and set during the construction of the Seq object, either explicity as an argument to the constructor or by the software using either the default value of the ref sequence length or the end value detected by the alignment program.
.PP
\fIseq\fR
.IX Subsection "seq"
.PP
.Vb 3
\& $seq\->seq;         # string representing the full sequence
\& $seq\->seq($n)      # single moiety at position $n
\& $seq\->seq($s,$e)   # string of moieties in the range $s to $e
.Ve
.PP
Returns a string of all or part of the sequence represented by the Seq object.  Don't confuse this method with the seq method of Mitomaster objects.  The result of this method is a string value, while the Mitomaster seq method produces new Seq objects.  Similar to the ref_seq method, the result returned is contextual: a Seq object will return a string representing \s-1DNA\s0, RNASeq produces \s-1RNA\s0, and AASeq objects produce amino acid strings.  \s-1RNA\s0 and \s-1AA\s0 seqs are also assumed to be linear, so calling the seq method on an RNASeq object in which the start index is larger than the end index (e.g. \f(CW$rna_seq\fR\->seq(500,10) will produce an error.
.PP
\fIstart\fR
.IX Subsection "start"
.PP
Retrieves the sequence start value.  This value is readonly and set during the construction of the Seq object, either explicity as an argument to the constructor or using the default value specified in the species meta-data file.
.PP
\fItranscribe\fR
.IX Subsection "transcribe"
.PP
Can only be called on a \s-1DNA\s0 Seq object and produces a Bio::Mitomaster::RNASeq object.  The locus \s-1ID\s0 designating the locus to be transcribed must be specified.  As you might expect, you will get an error if the locus you specify is not a coding one or the range of the Seq object does not cover the range of the locus.
.PP
.Vb 1
\& $rna_seq = $dna_seq\->transcribe(locus=>5);
.Ve
.PP
\fIvariants\fR
.IX Subsection "variants"
.PP
.Vb 1
\& $seq\->variants(codons=>1)
.Ve
.PP
Retrieves a hash reference to the list of variants indexed by position.  Positions will always be with respect to the reference sequence used during instantiation, but will be with respect to the \s-1DNA\s0 sequence for \s-1DNA\s0 Seq objects and the transcript or translation for \s-1RNA\s0 and \s-1AA\s0 Seq objects.  Likewise, variants are adjusted to be single letter \s-1IUPAC\s0 codes representing \s-1DNA\s0, \s-1RNA\s0, or \s-1AA\s0 moieties.  When called on an \s-1AA\s0 Seq with the 'codons' flag set, codon values are returned, along with frame changes attached as a comma separated value.
.PP
\fItranslate\fR
.IX Subsection "translate"
.PP
Can only be called on an \s-1RNA\s0 Seq object and produces a Bio::Mitomaster::AASeq object.  Unlike the transcribe method, no locus \s-1ID\s0 argment is needed since the \s-1RNA\s0 Seq object is specific for a particular locus.
.PP
.Vb 1
\& $aa_seq = $rna_seq\->translate;
.Ve
.SH "FILETYPES"
.IX Header "FILETYPES"
.SS "Standard Types"
.IX Subsection "Standard Types"
File types must be correctly formatted and have a recognizable extension.  Supported types:
.PP
.Vb 1
\& Type                   Extensions
\&
\& fasta                  .fas, .fasta
\& genbank                .gen, .genbank
\& variant                .variant, .variants
.Ve
.SS "variant File Type"
.IX Subsection "variant File Type"
Variant files combine the descriptor lines (the ones that begin with '>') used in fasta files with an abbreviated notation to describe variants.  Here's an example of variant file formatting:
.PP
.Vb 6
\& >Seq1|Human|Inuit
\& 100A
\& 111\-
\& 222\-\-
\& 303\-7
\& 455iCC
.Ve
.PP
Descriptive information about the sequence is on a line by itself following a '>'.  It can include multiple pieces of information separated by a pipe ('|').  Following the descriptor line are the variants specified using an abbreviated syntax.  The sequence above has a polymorphism, three deletions, and an insertion.  Deletions can be represented using a dash for each deleted nucleotide.  Multi-base deletions can also be expressed with a quantifier appended to the end of a dash.  This sequence has a 2bp deletion at 222 and a 7bp deletion beginning at position 303.  Insertions are represented with an 'i' followed by the actual insert.  In the example, there is a \s-1CC\s0 insertion following position 455.  You may want to look at the mtDNA variant examples posted at <http://mammag.web.uci.edu/MITOMASTER/AlleleExamples>).
.SH "TREES"
.IX Header "TREES"
This is a placeholder for phylogeny.  Still working on this.
.SH "COMPRESSION"
.IX Header "COMPRESSION"
This is a placeholder for compression work.  Need to rewrite and import my code here.
.SH "SPECIES"
.IX Header "SPECIES"
The Mitomaster software must have access to a data file containing meta data for each species that it analyzes.  This data includes things like the reference sequences, locus regions, transcript sequences, translation sequences, and codon code for that species.  This data is encoded in a single \s-1YAML\s0 (a very simple markup language) file.  Creating support for a new species is as simple as adding a new \s-1YAML\s0 file.  Any contribution of new species data is appreciated and there is a website to help facilitate the process: <http://mitomaster.bio.uci.edu/MITOMASTER/SpeciesContrib>.
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
Each module in this software includes its own \s-1POD\s0 documentation, accessible with the perldoc command (e.g. perldoc Bio::Mitomaster); however, most modules are not really intended to provide a public interface.  Those modules whose documentation you may want to have a look at:
.IP "Bio::Mitomaster" 4
.IX Item "Bio::Mitomaster"
.PD 0
.IP "Bio::Mitomaster::Seq" 4
.IX Item "Bio::Mitomaster::Seq"
.IP "Bio::Mitomaster::RNASeq" 4
.IX Item "Bio::Mitomaster::RNASeq"
.IP "Bio::Mitomaster::AASeq" 4
.IX Item "Bio::Mitomaster::AASeq"
.PD
.PP
You can email specific questions not addressed in the documentation to Marty Brandon \f(CW\*(C`mbrandon at computer.org\*(C'\fR
.PP
Bio::Mitomaster is distributed on the \s-1CPAN:\s0 http://search.cpan.org/dist/Bio\-Mitomaster\-MitoSeq/ <http://search.cpan.org/dist/Bio-Mitomaster-MitoSeq/>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009 Marty Brandon, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
